<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Editor</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: #16213e;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            border-bottom: 1px solid #0f3460;
        }

        header h1 {
            font-size: 18px;
            font-weight: 500;
            color: #e94560;
        }

        .plate-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .plate-selector label {
            color: #888;
            font-size: 14px;
        }

        .plate-selector select {
            background: #0f3460;
            color: #fff;
            border: 1px solid #1a1a2e;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            min-width: 150px;
        }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .toolbar button {
            background: #0f3460;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s;
        }

        .toolbar button:hover:not(:disabled) {
            background: #1a4a7a;
        }

        .toolbar button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .toolbar button.danger {
            background: #8b0000;
        }

        .toolbar button.danger:hover:not(:disabled) {
            background: #a52a2a;
        }

        .toolbar button.primary {
            background: #0a8754;
        }

        .toolbar button.primary:hover:not(:disabled) {
            background: #0fa968;
        }

        .toolbar button.merge {
            background: #6b4ba8;
        }

        .toolbar button.merge:hover:not(:disabled) {
            background: #7d5cc0;
        }

        .status {
            font-size: 13px;
            color: #888;
            padding: 0 10px;
        }

        .status .count {
            color: #e94560;
            font-weight: 500;
        }

        main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #16213e;
            border-right: 1px solid #0f3460;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid #0f3460;
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px 12px;
            background: transparent;
            border: none;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
            border-bottom: 2px solid transparent;
        }

        .sidebar-tab:hover {
            color: #ccc;
            background: rgba(255,255,255,0.05);
        }

        .sidebar-tab.active {
            color: #fff;
            border-bottom-color: #e94560;
        }

        .sidebar-tab .tab-count {
            background: #0f3460;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            margin-left: 6px;
        }

        .sidebar-tab.active .tab-count {
            background: #e94560;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
        }

        .tab-content.active {
            display: flex;
        }

        .sidebar-header {
            padding: 12px 16px;
            border-bottom: 1px solid #0f3460;
            font-size: 13px;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .block-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .deleted-item {
            padding: 10px 12px;
            background: #2a1a1a;
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.15s;
            border-left: 3px solid #8b0000;
        }

        .deleted-item:hover {
            background: #3a2525;
        }

        .deleted-item.selected {
            background: #4a2a2a;
            outline: 2px solid #cc5555;
        }

        .restore-btn {
            background: #3a506b;
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            margin-left: auto;
        }

        .restore-btn:hover {
            background: #4a6a8b;
        }

        .block-item {
            padding: 10px 12px;
            background: #1a1a2e;
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.15s;
        }

        .block-item:hover {
            background: #252542;
        }

        .block-item.selected {
            background: #2a4a6a;
            outline: 2px solid #4a8aca;
        }

        .block-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .block-id {
            font-size: 13px;
            font-weight: 500;
        }

        .block-vertices {
            font-size: 11px;
            color: #666;
            margin-left: auto;
        }

        .canvas-container {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: #111;
        }

        #canvas-wrapper {
            width: 100%;
            height: 100%;
            overflow: auto;
            cursor: grab;
        }

        #canvas-wrapper.dragging {
            cursor: grabbing;
        }

        #svg-container {
            position: relative;
        }

        #svg-canvas {
            display: block;
            transform-origin: 0 0;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            background: rgba(22, 33, 62, 0.9);
            padding: 8px;
            border-radius: 6px;
        }

        .zoom-controls button {
            background: #0f3460;
            color: #fff;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
        }

        .zoom-controls button:hover {
            background: #1a4a7a;
        }

        .zoom-level {
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 13px;
            color: #888;
        }

        .help-text {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 12px;
            color: #888;
            line-height: 1.6;
        }

        .help-text kbd {
            background: #0f3460;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #ccc;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 16px;
        }

        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #16213e;
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
            border: 1px solid #0f3460;
        }

        .toast.success {
            border-color: #0a8754;
        }

        .toast.error {
            border-color: #8b0000;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            15% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }

        /* SVG polygon styles */
        .svg-polygon {
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .svg-polygon:hover {
            opacity: 0.8;
        }

        .svg-polygon.selected {
            stroke: white !important;
            stroke-width: 4 !important;
            stroke-dasharray: 10 5 !important;
        }

        .svg-polygon.hidden {
            display: none;
        }

        .block-item.hidden {
            opacity: 0.4;
            text-decoration: line-through;
        }

        .block-name {
            font-size: 13px;
            font-weight: 500;
            flex: 1;
            min-width: 0;
        }

        .block-name-input {
            background: #0f3460;
            border: 1px solid #4a8aca;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 3px;
            width: 100%;
            outline: none;
        }

        .block-name-input:focus {
            border-color: #6ab0f0;
        }

        /* SVG label styles */
        .svg-label {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 24px;
            font-weight: bold;
            fill: white;
            stroke: black;
            stroke-width: 3;
            paint-order: stroke;
            pointer-events: none;
            user-select: none;
        }

        .svg-label.labels-hidden {
            display: none;
        }

        .toolbar button.toggle {
            background: #3a506b;
        }

        .toolbar button.toggle.active {
            background: #5a9fd4;
        }

        .toolbar button.toggle:hover:not(:disabled) {
            background: #4a6a8b;
        }

        .toolbar button.toggle.active:hover:not(:disabled) {
            background: #6ab0e7;
        }

        .background-selector {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 10px;
        }

        .background-selector label {
            color: #888;
            font-size: 12px;
            white-space: nowrap;
        }

        .background-selector select {
            background: #0f3460;
            color: #fff;
            border: 1px solid #1a1a2e;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 13px;
        }

        .area-filter {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 10px;
        }

        .area-filter label {
            color: #888;
            font-size: 12px;
            white-space: nowrap;
        }

        .area-filter input {
            background: #0f3460;
            color: #fff;
            border: 1px solid #1a1a2e;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 13px;
            width: 70px;
            text-align: right;
        }

        .area-filter input:focus {
            outline: none;
            border-color: #4a8aca;
        }

        .toolbar button.isolate {
            background: #8b6914;
        }

        .toolbar button.isolate:hover:not(:disabled) {
            background: #a57d1a;
        }

        .complexity-filter {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 10px;
        }

        .complexity-filter label {
            color: #888;
            font-size: 12px;
            white-space: nowrap;
        }

        .complexity-filter input {
            background: #0f3460;
            color: #fff;
            border: 1px solid #1a1a2e;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 13px;
            width: 70px;
            text-align: right;
        }

        .complexity-filter input:focus {
            outline: none;
            border-color: #4a8aca;
        }

        .toolbar button.select-complexity {
            background: #5a4a8b;
        }

        .toolbar button.select-complexity:hover:not(:disabled) {
            background: #6b5a9c;
        }
    </style>
</head>
<body>
    <header>
        <h1>SVG Editor</h1>
        <div class="plate-selector">
            <label>Plate:</label>
            <select id="plate-select">
                <option value="">Loading...</option>
            </select>
        </div>
        <div class="status">
            <span id="block-count"></span>
            <span id="selection-count"></span>
        </div>
        <div class="toolbar">
            <div class="background-selector">
                <label>Background:</label>
                <select id="background-mode">
                    <option value="image">Image</option>
                    <option value="desaturated">Desaturated</option>
                    <option value="gray">Gray</option>
                    <option value="white">White</option>
                </select>
            </div>
            <div class="area-filter">
                <label>Area ≤</label>
                <input type="number" id="area-threshold" value="100" min="0" step="10">
            </div>
            <button id="btn-isolate" class="isolate" disabled title="Isolate small polygons (I)">Isolate</button>
            <div class="complexity-filter">
                <label>Complexity ≤</label>
                <input type="number" id="complexity-threshold" value="10" min="0" step="1">
            </div>
            <button id="btn-select-complexity" class="select-complexity" disabled title="Select polygons by complexity (area/points)">Select</button>
            <button id="btn-save" class="primary" disabled>Save Changes</button>
        </div>
    </header>

    <main>
        <div class="sidebar">
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" data-tab="blocks">
                    Blocks<span class="tab-count" id="blocks-count">0</span>
                </button>
                <button class="sidebar-tab" data-tab="deleted">
                    To Delete<span class="tab-count" id="deleted-count">0</span>
                </button>
            </div>
            <div class="tab-content active" id="tab-blocks">
                <div class="block-list" id="block-list"></div>
            </div>
            <div class="tab-content" id="tab-deleted">
                <div class="sidebar-header">
                    <span>Pending deletion</span>
                    <button id="btn-undelete" class="restore-btn" disabled>Undelete Last</button>
                </div>
                <div class="block-list" id="deleted-list"></div>
            </div>
        </div>

        <div class="canvas-container">
            <div id="canvas-wrapper">
                <div id="svg-container">
                    <svg id="svg-canvas"></svg>
                </div>
            </div>
            <div class="loading" id="loading">Select a plate to begin</div>

            <div class="zoom-controls">
                <button id="btn-zoom-out">-</button>
                <div class="zoom-level"><span id="zoom-level">100%</span></div>
                <button id="btn-zoom-in">+</button>
                <button id="btn-zoom-fit">Fit</button>
            </div>

            <div class="help-text">
                <kbd>Click</kbd> Select &nbsp;
                <kbd>Shift+Click</kbd> Multi-select &nbsp;
                <kbd>Dbl-Click</kbd> Rename &nbsp;
                <kbd>Delete</kbd> Delete &nbsp;
                <kbd>U</kbd> Undelete &nbsp;
                <kbd>M</kbd> Merge &nbsp;
                <kbd>Z</kbd> Cut from overlapping &nbsp;
                <kbd>H</kbd> Hide &nbsp;
                <kbd>S</kbd> Show all &nbsp;
                <kbd>I</kbd> Isolate small &nbsp;
                <kbd>X</kbd> Del visible &nbsp;
                <kbd>L</kbd> Labels &nbsp;
                <kbd>F</kbd> Flash &nbsp;
                <kbd>Ctrl+S</kbd> Save
            </div>
        </div>
    </main>

    <script>
        // State
        let plates = [];
        let currentPlate = null;
        let currentSvgType = 'plate';  // 'plate' or 'segmentation'
        let polygons = [];  // Used for both modes (flattened structure)
        let containerBlocks = [];  // Container blocks info (segmentation mode)
        let deletedPolygons = [];  // Polygons pending deletion
        let deleteHistory = [];     // Stack of deletion batches for undo
        let selectedIds = new Set();
        let hiddenIds = new Set();
        let zoom = 0.25;  // Start at 25% zoom for large images
        let hasChanges = false;
        let showLabels = true;
        let activeTab = 'blocks';
        let backgroundMode = 'image';  // 'white', 'gray', 'image', 'desaturated'
        let currentSvgData = null;  // Store current SVG data for re-renders
        let flashInterval = null;  // Interval ID for flash animation
        let isolationMode = null;  // 'area', 'complexity', or null

        // DOM elements
        const plateSelect = document.getElementById('plate-select');
        const blockList = document.getElementById('block-list');
        const svgCanvas = document.getElementById('svg-canvas');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const loading = document.getElementById('loading');

        const btnSave = document.getElementById('btn-save');
        const btnZoomIn = document.getElementById('btn-zoom-in');
        const btnZoomOut = document.getElementById('btn-zoom-out');
        const btnZoomFit = document.getElementById('btn-zoom-fit');
        const btnUndelete = document.getElementById('btn-undelete');
        const deletedList = document.getElementById('deleted-list');
        const areaThreshold = document.getElementById('area-threshold');
        const btnIsolate = document.getElementById('btn-isolate');
        const complexityThreshold = document.getElementById('complexity-threshold');
        const btnSelectComplexity = document.getElementById('btn-select-complexity');
        const backgroundModeSelect = document.getElementById('background-mode');

        // Initialize
        async function init() {
            await loadPlates();
            setupEventListeners();

            // Check URL for plate selection
            loadPlateFromURL();
        }

        function loadPlateFromURL() {
            const params = new URLSearchParams(window.location.search);
            const volume = params.get('volume');
            const plateId = params.get('plate');
            const svgType = params.get('type') || 'plate';

            if (volume && plateId) {
                // Find the matching plate in the list
                const idx = plates.findIndex(p =>
                    p.volume === volume &&
                    p.plate_id === plateId &&
                    p.svg_type === svgType
                );

                if (idx >= 0) {
                    plateSelect.value = idx;
                    loadPlate(idx);
                }
            }
        }

        function updateURL(plate) {
            if (!plate) return;

            const params = new URLSearchParams();
            params.set('volume', plate.volume);
            params.set('plate', plate.plate_id);
            params.set('type', plate.svg_type || 'plate');

            const newURL = `${window.location.pathname}?${params.toString()}`;
            history.replaceState(null, '', newURL);
        }

        async function loadPlates() {
            try {
                const response = await fetch('/api/plates');
                plates = await response.json();

                plateSelect.innerHTML = '<option value="">Select a plate...</option>';
                plates.forEach((plate, idx) => {
                    const option = document.createElement('option');
                    option.value = idx;
                    const svgType = plate.svg_type || 'plate';
                    const typeLabel = svgType === 'segmentation' ? ' [segmentation]' : ' [plate]';
                    option.textContent = `${plate.volume}/${plate.plate_id}${typeLabel}`;
                    if (!plate.has_jpeg) {
                        option.textContent += ' (no JPEG)';
                    }
                    plateSelect.appendChild(option);
                });
            } catch (error) {
                showToast('Failed to load plates', 'error');
            }
        }

        async function loadPlate(index) {
            const plate = plates[index];
            if (!plate) return;

            // Stop any active flash animation
            if (flashInterval) {
                clearInterval(flashInterval);
                flashInterval = null;
            }

            loading.textContent = 'Loading...';
            loading.style.display = 'block';

            currentSvgType = plate.svg_type || 'plate';

            try {
                let response;
                if (currentSvgType === 'segmentation') {
                    response = await fetch(`/api/segmentation/${plate.volume}/${plate.plate_id}`);
                } else {
                    response = await fetch(`/api/plate/${plate.volume}/${plate.plate_id}`);
                }
                const data = await response.json();

                currentPlate = plate;
                currentSvgData = data;

                if (currentSvgType === 'segmentation') {
                    // Segmentation mode: now uses flattened polygon structure
                    polygons = data.polygons.map((p, idx) => ({
                        ...p,
                        originalIndex: idx
                    }));
                    containerBlocks = data.container_blocks || [];
                } else {
                    // Plate mode: work with polygons directly
                    polygons = data.polygons.map((p, idx) => ({
                        ...p,
                        originalIndex: idx,
                        name: p.name || `b-${String(idx + 1).padStart(4, '0')}`
                    }));
                    containerBlocks = [];
                }

                deletedPolygons = [];
                deleteHistory = [];
                hiddenIds.clear();
                isolationMode = null;
                hasChanges = false;

                // Auto-hide labels if more than 200 shapes (performance/clutter)
                showLabels = polygons.length <= 200;

                renderSVG(data);
                renderBlockList();
                renderDeletedList();
                updateTabCounts();
                updateStatus();
                updateButtons();

                loading.style.display = 'none';

                // Update URL to reflect current plate
                updateURL(plate);

                // Fit to view
                fitToView();

            } catch (error) {
                showToast('Failed to load plate', 'error');
                loading.textContent = 'Failed to load';
            }
        }

        function renderSVG(data) {
            const width = parseInt(data.width) || 1000;
            const height = parseInt(data.height) || 1000;

            // Clear existing
            svgCanvas.innerHTML = '';
            svgCanvas.setAttribute('width', width);
            svgCanvas.setAttribute('height', height);
            svgCanvas.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Add background based on mode
            if (backgroundMode === 'white') {
                const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bg.setAttribute('width', width);
                bg.setAttribute('height', height);
                bg.setAttribute('fill', '#ffffff');
                svgCanvas.appendChild(bg);
            } else if (backgroundMode === 'gray') {
                const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bg.setAttribute('width', width);
                bg.setAttribute('height', height);
                bg.setAttribute('fill', '#808080');
                svgCanvas.appendChild(bg);
            } else if (currentPlate && currentPlate.has_jpeg) {
                // Add SVG filter for desaturation
                if (backgroundMode === 'desaturated') {
                    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    defs.innerHTML = `
                        <filter id="grayscale">
                            <feColorMatrix type="saturate" values="0"/>
                        </filter>
                    `;
                    svgCanvas.appendChild(defs);
                }

                const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                image.setAttribute('href', `/media/${currentPlate.plate_id}.jpeg`);
                image.setAttribute('width', width);
                image.setAttribute('height', height);
                image.setAttribute('opacity', '0.7');
                if (backgroundMode === 'desaturated') {
                    image.setAttribute('filter', 'url(#grayscale)');
                }
                svgCanvas.appendChild(image);
            }

            if (currentSvgType === 'segmentation') {
                // Segmentation mode: render block outlines then flattened polygons
                renderSegmentationSVG(data);
            } else {
                // Plate mode: render polygons directly
                renderPlateSVG(data);
            }

            applyZoom();
        }

        function renderPlateSVG(data) {
            // Add polygons
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.id = 'polygons';

            polygons.forEach((poly, idx) => {
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', poly.points);
                polygon.setAttribute('fill', poly.fill || 'rgba(100,150,200,0.3)');
                polygon.setAttribute('stroke', poly.stroke || 'rgb(100,150,200)');
                polygon.setAttribute('stroke-width', '2');
                polygon.setAttribute('data-index', idx);
                polygon.classList.add('svg-polygon');

                if (selectedIds.has(idx)) {
                    polygon.classList.add('selected');
                }
                if (hiddenIds.has(idx)) {
                    polygon.classList.add('hidden');
                }

                polygon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handlePolygonClick(idx, e.shiftKey);
                });

                group.appendChild(polygon);
            });

            svgCanvas.appendChild(group);

            // Add labels group
            const labelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            labelsGroup.id = 'labels';

            polygons.forEach((poly, idx) => {
                const centroid = calculateCentroid(poly.points);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', centroid.x);
                label.setAttribute('y', centroid.y);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('dominant-baseline', 'middle');
                label.setAttribute('data-index', idx);
                label.classList.add('svg-label');
                if (!showLabels) {
                    label.classList.add('labels-hidden');
                }
                if (hiddenIds.has(idx)) {
                    label.classList.add('labels-hidden');
                }
                label.textContent = poly.name || `b-${String(idx + 1).padStart(4, '0')}`;

                labelsGroup.appendChild(label);
            });

            svgCanvas.appendChild(labelsGroup);
        }

        function renderSegmentationSVG(data) {
            // Render block outlines (from plate.svg layer) - non-interactive reference layer
            if (data.block_outlines && data.block_outlines.length > 0) {
                const outlinesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                outlinesGroup.id = 'block-outlines';
                outlinesGroup.setAttribute('opacity', '0.3');
                outlinesGroup.style.pointerEvents = 'none';

                data.block_outlines.forEach(outline => {
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', outline.points);
                    polygon.setAttribute('fill', 'none');
                    polygon.setAttribute('stroke', outline.stroke || 'rgb(102,179,92)');
                    polygon.setAttribute('stroke-width', '3');
                    polygon.setAttribute('stroke-dasharray', '10,5');
                    outlinesGroup.appendChild(polygon);
                });

                svgCanvas.appendChild(outlinesGroup);
            }

            // Render flattened polygons (each polygon now has its own plate_x, plate_y)
            const polygonsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            polygonsGroup.id = 'polygons';

            polygons.forEach((poly, idx) => {
                // Each polygon is rendered in its plate coordinates
                const plateX = poly.plate_x || 0;
                const plateY = poly.plate_y || 0;

                // Create a group for this polygon to handle the offset
                const polyGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                polyGroup.setAttribute('transform', `translate(${plateX},${plateY})`);

                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', poly.points);
                polygon.setAttribute('fill', poly.fill || 'rgba(100,150,200,0.5)');
                polygon.setAttribute('stroke', poly.stroke || 'rgb(100,150,200)');
                polygon.setAttribute('stroke-width', '1');
                polygon.setAttribute('data-index', idx);
                polygon.classList.add('svg-polygon');

                if (selectedIds.has(idx)) {
                    polygon.classList.add('selected');
                }
                if (hiddenIds.has(idx)) {
                    polygon.classList.add('hidden');
                }

                polygon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handlePolygonClick(idx, e.shiftKey);
                });

                polyGroup.appendChild(polygon);
                polygonsGroup.appendChild(polyGroup);
            });

            svgCanvas.appendChild(polygonsGroup);

            // Add labels group for polygons
            const labelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            labelsGroup.id = 'labels';

            polygons.forEach((poly, idx) => {
                const plateX = poly.plate_x || 0;
                const plateY = poly.plate_y || 0;

                // Calculate centroid from polygon points
                const centroid = calculateCentroid(poly.points);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', plateX + centroid.x);
                label.setAttribute('y', plateY + centroid.y);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('dominant-baseline', 'middle');
                label.setAttribute('data-index', idx);
                label.classList.add('svg-label');
                if (!showLabels) {
                    label.classList.add('labels-hidden');
                }
                if (hiddenIds.has(idx)) {
                    label.classList.add('labels-hidden');
                }
                // Use short name: poly_id (p-###) if available, otherwise block_id (b-####)
                let shortName = poly.poly_id || `b-${poly.block_id}`;
                label.textContent = shortName;

                labelsGroup.appendChild(label);
            });

            svgCanvas.appendChild(labelsGroup);
        }

        function parsePolygonPointsForBBox(pointsStr) {
            const points = [];
            for (const pair of pointsStr.trim().split(/\s+/)) {
                if (pair.includes(',')) {
                    const [x, y] = pair.split(',').map(Number);
                    if (!isNaN(x) && !isNaN(y)) {
                        points.push({ x, y });
                    }
                }
            }
            return points;
        }

        function calculateCentroid(pointsStr) {
            const points = [];
            for (const pair of pointsStr.trim().split(/\s+/)) {
                if (pair.includes(',')) {
                    const [x, y] = pair.split(',').map(Number);
                    if (!isNaN(x) && !isNaN(y)) {
                        points.push({ x, y });
                    }
                }
            }

            if (points.length === 0) {
                return { x: 0, y: 0 };
            }

            // Simple centroid calculation (average of all points)
            const sum = points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
            return {
                x: Math.round(sum.x / points.length),
                y: Math.round(sum.y / points.length)
            };
        }

        function calculatePolygonArea(pointsStr) {
            // Shoelace formula for polygon area
            const points = [];
            for (const pair of pointsStr.trim().split(/\s+/)) {
                if (pair.includes(',')) {
                    const [x, y] = pair.split(',').map(Number);
                    if (!isNaN(x) && !isNaN(y)) {
                        points.push({ x, y });
                    }
                }
            }

            if (points.length < 3) return 0;

            let area = 0;
            const n = points.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return Math.abs(area) / 2;
        }

        function countPolygonPoints(pointsStr) {
            let count = 0;
            for (const pair of pointsStr.trim().split(/\s+/)) {
                if (pair.includes(',')) {
                    count++;
                }
            }
            return count;
        }

        function calculatePolygonComplexity(pointsStr) {
            const area = calculatePolygonArea(pointsStr);
            const numPoints = countPolygonPoints(pointsStr);
            if (numPoints === 0) return Infinity;
            return area / numPoints;
        }

        function renderBlockList() {
            blockList.innerHTML = '';

            // Both modes now use the unified polygons array
            polygons.forEach((poly, idx) => {
                const item = document.createElement('div');
                item.className = 'block-item';
                if (selectedIds.has(idx)) {
                    item.classList.add('selected');
                }
                if (hiddenIds.has(idx)) {
                    item.classList.add('hidden');
                }
                item.dataset.index = idx;

                // Count vertices
                const vertexCount = (poly.points.match(/,/g) || []).length;
                const displayName = poly.name || poly.id || `poly-${idx}`;

                // Add indicator for container children in segmentation mode
                let containerIndicator = '';
                if (currentSvgType === 'segmentation' && poly.is_container_child) {
                    containerIndicator = ' ⤷';  // Shows this is inside a container block
                }

                item.innerHTML = `
                    <div class="block-color" style="background: ${poly.stroke || '#666'}"></div>
                    <span class="block-name" data-index="${idx}">${displayName}${containerIndicator}</span>
                    <span class="block-vertices">${vertexCount} pts</span>
                `;

                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('block-name-input')) {
                        handlePolygonClick(idx, e.shiftKey);
                    }
                });

                // Double-click to rename (plate mode only for now)
                if (currentSvgType === 'plate') {
                    const nameSpan = item.querySelector('.block-name');
                    nameSpan.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        startRenaming(idx, nameSpan);
                    });
                }

                blockList.appendChild(item);
            });
        }

        function renderDeletedList() {
            deletedList.innerHTML = '';

            // Both modes now use the unified deletedPolygons array
            deletedPolygons.forEach((poly, idx) => {
                const item = document.createElement('div');
                item.className = 'deleted-item';
                item.dataset.index = idx;

                const vertexCount = (poly.points.match(/,/g) || []).length;
                const displayName = poly.name || poly.id || 'unnamed';

                item.innerHTML = `
                    <div class="block-color" style="background: ${poly.stroke || '#666'}"></div>
                    <span class="block-name">${displayName}</span>
                    <span class="block-vertices">${vertexCount} pts</span>
                    <button class="restore-btn" data-index="${idx}">Restore</button>
                `;

                // Restore button handler
                item.querySelector('.restore-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    restorePolygon(idx);
                });

                deletedList.appendChild(item);
            });
        }

        function updateTabCounts() {
            // Both modes now use unified structure
            document.getElementById('blocks-count').textContent = polygons.length;
            document.getElementById('deleted-count').textContent = deletedPolygons.length;
        }

        function switchTab(tabName) {
            activeTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.sidebar-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update tab content
            document.getElementById('tab-blocks').classList.toggle('active', tabName === 'blocks');
            document.getElementById('tab-deleted').classList.toggle('active', tabName === 'deleted');
        }

        function startRenaming(idx, nameSpan) {
            const poly = polygons[idx];
            const currentName = poly.name || `b-${String(idx + 1).padStart(4, '0')}`;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'block-name-input';
            input.value = currentName;

            nameSpan.innerHTML = '';
            nameSpan.appendChild(input);
            input.focus();
            input.select();

            const finishRenaming = () => {
                const newName = input.value.trim() || `b-${String(idx + 1).padStart(4, '0')}`;
                if (newName !== currentName) {
                    polygons[idx].name = newName;
                    hasChanges = true;
                    updateButtons();

                    // Update SVG label
                    const label = document.querySelector(`.svg-label[data-index="${idx}"]`);
                    if (label) {
                        label.textContent = newName;
                    }
                }
                nameSpan.textContent = newName;
            };

            input.addEventListener('blur', finishRenaming);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    nameSpan.textContent = currentName;
                }
            });
        }

        function handlePolygonClick(index, multiSelect) {
            if (multiSelect) {
                if (selectedIds.has(index)) {
                    selectedIds.delete(index);
                } else {
                    selectedIds.add(index);
                }
            } else {
                if (selectedIds.has(index) && selectedIds.size === 1) {
                    selectedIds.clear();
                } else {
                    selectedIds.clear();
                    selectedIds.add(index);
                }
            }

            updateSelection();
        }

        function updateSelection() {
            // Update SVG polygons
            document.querySelectorAll('.svg-polygon').forEach(poly => {
                const idx = parseInt(poly.dataset.index);
                poly.classList.toggle('selected', selectedIds.has(idx));
                poly.classList.toggle('hidden', hiddenIds.has(idx));
            });

            // Update SVG labels
            document.querySelectorAll('.svg-label').forEach(label => {
                const idx = parseInt(label.dataset.index);
                const isHidden = hiddenIds.has(idx);
                label.classList.toggle('labels-hidden', !showLabels || isHidden);
            });

            // Update block list
            document.querySelectorAll('.block-item').forEach(item => {
                const idx = parseInt(item.dataset.index);
                item.classList.toggle('selected', selectedIds.has(idx));
                item.classList.toggle('hidden', hiddenIds.has(idx));

                // Scroll into view if selected
                if (selectedIds.has(idx) && selectedIds.size === 1) {
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            });

            updateStatus();
            updateButtons();
        }

        function updateStatus() {
            const blockCount = document.getElementById('block-count');
            const selectionCount = document.getElementById('selection-count');

            // Both modes now use unified structure
            const count = polygons.length;
            const typeLabel = currentSvgType === 'segmentation' ? 'polygons' : 'blocks';
            blockCount.textContent = `${count} ${typeLabel}`;

            if (selectedIds.size > 0) {
                selectionCount.textContent = ` | ${selectedIds.size} selected`;
            } else {
                selectionCount.textContent = '';
            }

            if (hasChanges) {
                document.title = '* SVG Editor';
            } else {
                document.title = 'SVG Editor';
            }
        }

        function updateButtons() {
            const hasPlate = currentPlate !== null;
            const canUndo = deleteHistory.length > 0;

            // Both modes now use unified structure
            const itemCount = polygons.length;

            btnSave.disabled = !hasChanges;
            btnUndelete.disabled = !canUndo;
            btnIsolate.disabled = !hasPlate || itemCount === 0;
            btnSelectComplexity.disabled = !hasPlate || itemCount === 0;
        }

        function selectAll() {
            selectedIds.clear();
            // Both modes now use unified structure
            polygons.forEach((_, idx) => selectedIds.add(idx));
            updateSelection();
        }

        function deselectAll() {
            selectedIds.clear();
            updateSelection();
        }

        function hideSelected() {
            if (selectedIds.size === 0) {
                // Hide all polygons when none selected
                const count = polygons.length - hiddenIds.size;
                if (count === 0) return;
                polygons.forEach((_, idx) => hiddenIds.add(idx));
                updateSelection();
                showToast(`Hidden all ${count} polygon(s)`, 'success');
                return;
            }

            const count = selectedIds.size;
            selectedIds.forEach(idx => hiddenIds.add(idx));
            selectedIds.clear();
            updateSelection();

            showToast(`Hidden ${count} block(s)`, 'success');
        }

        function showAll() {
            if (hiddenIds.size === 0 && isolationMode === null) return;

            const count = hiddenIds.size;
            hiddenIds.clear();
            isolationMode = null;
            updateSelection();

            showToast(`Showing ${count} block(s)`, 'success');
        }

        function reapplyIsolationMode() {
            // Silently reapply the current isolation mode without toast messages
            if (isolationMode === 'area') {
                const threshold = parseFloat(areaThreshold.value) || 100;
                polygons.forEach((poly, idx) => {
                    const area = calculatePolygonArea(poly.points);
                    if (area > threshold) {
                        hiddenIds.add(idx);
                    } else {
                        hiddenIds.delete(idx);
                    }
                });
            } else if (isolationMode === 'complexity') {
                const complexityThresh = parseFloat(complexityThreshold.value) || 10;
                const areaThresh = parseFloat(areaThreshold.value) || 100;
                polygons.forEach((poly, idx) => {
                    const area = calculatePolygonArea(poly.points);
                    const complexity = calculatePolygonComplexity(poly.points);
                    if (area <= areaThresh && complexity <= complexityThresh) {
                        hiddenIds.delete(idx);
                    } else {
                        hiddenIds.add(idx);
                    }
                });
            }
        }

        function isolateSmall() {
            const threshold = parseFloat(areaThreshold.value) || 100;

            let hiddenCount = 0;
            let visibleCount = 0;

            polygons.forEach((poly, idx) => {
                const area = calculatePolygonArea(poly.points);
                if (area > threshold) {
                    hiddenIds.add(idx);
                    hiddenCount++;
                } else {
                    hiddenIds.delete(idx);
                    visibleCount++;
                }
            });

            selectedIds.clear();
            isolationMode = 'area';
            updateSelection();

            showToast(`Isolated ${visibleCount} polygons with area ≤ ${threshold} (hid ${hiddenCount})`, 'success');
        }

        function isolateByComplexity() {
            const complexityThresh = parseFloat(complexityThreshold.value) || 10;
            const areaThresh = parseFloat(areaThreshold.value) || 100;

            let hiddenCount = 0;
            let visibleCount = 0;

            polygons.forEach((poly, idx) => {
                const area = calculatePolygonArea(poly.points);
                const complexity = calculatePolygonComplexity(poly.points);

                // Polygon must satisfy both: area ≤ areaThresh AND complexity ≤ complexityThresh
                if (area <= areaThresh && complexity <= complexityThresh) {
                    hiddenIds.delete(idx);
                    visibleCount++;
                } else {
                    hiddenIds.add(idx);
                    hiddenCount++;
                }
            });

            selectedIds.clear();
            isolationMode = 'complexity';
            updateSelection();

            showToast(`Isolated ${visibleCount} polygons with area ≤ ${areaThresh} and complexity ≤ ${complexityThresh} (hid ${hiddenCount})`, 'success');
        }

        function deleteVisible() {
            // Get all visible (non-hidden) polygon indices
            const visibleIndices = [];
            polygons.forEach((_, idx) => {
                if (!hiddenIds.has(idx)) {
                    visibleIndices.push(idx);
                }
            });

            if (visibleIndices.length === 0) {
                showToast('No visible polygons to delete', 'error');
                return;
            }

            const count = visibleIndices.length;

            // Add visible polygons to deleted list
            const deletedBatch = [];
            visibleIndices.forEach(idx => {
                const poly = polygons[idx];
                deletedBatch.push({
                    ...poly,
                    originalIndex: idx
                });
            });

            deletedPolygons.push(...deletedBatch);
            deleteHistory.push({
                count: deletedBatch.length,
                startIndex: deletedPolygons.length - deletedBatch.length,
                type: currentSvgType
            });

            // Create set for fast lookup
            const visibleSet = new Set(visibleIndices);

            // Rebuild hidden indices (only hidden ones remain, indices shift down)
            const newHiddenIds = new Set();
            let offset = 0;
            polygons.forEach((_, idx) => {
                if (visibleSet.has(idx)) {
                    offset++;
                } else if (hiddenIds.has(idx)) {
                    newHiddenIds.add(idx - offset);
                }
            });

            polygons = polygons.filter((_, idx) => !visibleSet.has(idx));
            hiddenIds = newHiddenIds;
            selectedIds.clear();
            hasChanges = true;

            renderSVG(currentSvgData);
            renderBlockList();
            renderDeletedList();
            updateTabCounts();
            updateStatus();
            updateButtons();

            const itemLabel = currentSvgType === 'segmentation' ? 'polygon(s)' : 'block(s)';
            showToast(`Deleted ${count} visible ${itemLabel}`, 'success');
        }

        function toggleLabels() {
            showLabels = !showLabels;

            document.querySelectorAll('.svg-label').forEach(label => {
                const idx = parseInt(label.dataset.index);
                const isHidden = hiddenIds.has(idx);
                label.classList.toggle('labels-hidden', !showLabels || isHidden);
            });
        }

        function toggleFlash() {
            if (flashInterval) {
                // Stop flashing - restore visibility
                clearInterval(flashInterval);
                flashInterval = null;
                document.querySelectorAll('.svg-polygon').forEach(poly => {
                    const idx = parseInt(poly.dataset.index);
                    if (!hiddenIds.has(idx)) {
                        poly.style.opacity = '';
                    }
                });
                showToast('Flash stopped', 'info');
            } else {
                // Start flashing
                let isVisible = true;
                flashInterval = setInterval(() => {
                    isVisible = !isVisible;
                    document.querySelectorAll('.svg-polygon').forEach(poly => {
                        const idx = parseInt(poly.dataset.index);
                        if (!hiddenIds.has(idx) && !selectedIds.has(idx)) {
                            poly.style.opacity = isVisible ? '' : '0.05';
                        }
                    });
                }, 400);  // Flash every 400ms
                showToast('Flashing polygons (press F to stop)', 'info');
            }
        }

        function deleteSelected() {
            if (selectedIds.size === 0) return;

            const count = selectedIds.size;
            const deletedIndices = Array.from(selectedIds).sort((a, b) => a - b);

            // Both modes now use unified structure
            const deletedBatch = [];
            deletedIndices.forEach(idx => {
                const poly = polygons[idx];
                deletedBatch.push({
                    ...poly,
                    originalIndex: idx
                });
            });

            // Add to deleted list and history
            deletedPolygons.push(...deletedBatch);
            deleteHistory.push({
                count: deletedBatch.length,
                startIndex: deletedPolygons.length - deletedBatch.length,
                type: currentSvgType
            });

            // Build new hidden indices after deletion
            const newHiddenIds = new Set();
            hiddenIds.forEach(hiddenIdx => {
                if (!selectedIds.has(hiddenIdx)) {
                    const offset = deletedIndices.filter(d => d < hiddenIdx).length;
                    newHiddenIds.add(hiddenIdx - offset);
                }
            });

            polygons = polygons.filter((_, idx) => !selectedIds.has(idx));
            hiddenIds = newHiddenIds;

            selectedIds.clear();
            hasChanges = true;

            renderSVG(currentSvgData);
            renderBlockList();
            renderDeletedList();
            updateTabCounts();
            updateStatus();
            updateButtons();

            const itemLabel = currentSvgType === 'segmentation' ? 'polygon(s)' : 'block(s)';
            showToast(`Moved ${count} ${itemLabel} to delete queue`, 'success');
        }

        function restorePolygon(deletedIdx) {
            if (deletedIdx < 0 || deletedIdx >= deletedPolygons.length) return;

            const poly = deletedPolygons[deletedIdx];
            deletedPolygons.splice(deletedIdx, 1);

            // Clear the history since we're manually restoring
            deleteHistory = [];

            // Add back to polygons
            polygons.push(poly);
            hasChanges = true;

            renderSVG(currentSvgData);
            renderBlockList();
            renderDeletedList();
            updateTabCounts();
            updateStatus();
            updateButtons();

            showToast(`Restored "${poly.name || 'block'}"`, 'success');
        }

        function undoDelete() {
            if (deleteHistory.length === 0) return;

            const lastBatch = deleteHistory.pop();

            // Both modes now use unified structure
            const restoredPolygons = deletedPolygons.splice(lastBatch.startIndex, lastBatch.count);
            polygons.push(...restoredPolygons);

            hasChanges = true;

            renderSVG(currentSvgData);
            renderBlockList();
            renderDeletedList();
            updateTabCounts();
            updateStatus();
            updateButtons();

            const itemLabel = currentSvgType === 'segmentation' ? 'polygon(s)' : 'block(s)';
            showToast(`Restored ${lastBatch.count} ${itemLabel}`, 'success');
        }

        async function mergeSelected() {
            if (selectedIds.size < 2) return;

            // Get selected polygon points
            const selectedPolygons = [];
            const selectedIndices = Array.from(selectedIds).sort((a, b) => a - b);

            selectedIndices.forEach(idx => {
                selectedPolygons.push(polygons[idx].points);
            });

            try {
                const response = await fetch('/api/merge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ polygons: selectedPolygons })
                });

                const result = await response.json();

                if (result.success && result.merged_polygons.length > 0) {
                    // Get color from first selected polygon
                    const firstSelected = polygons[selectedIndices[0]];

                    // Build new hidden indices after merge
                    const newHiddenIds = new Set();
                    hiddenIds.forEach(hiddenIdx => {
                        if (!selectedIds.has(hiddenIdx)) {
                            // Count how many merged items are before this index
                            const offset = selectedIndices.filter(d => d < hiddenIdx).length;
                            newHiddenIds.add(hiddenIdx - offset);
                        }
                    });

                    // Remove selected polygons
                    polygons = polygons.filter((_, idx) => !selectedIds.has(idx));

                    // Add merged polygon(s)
                    result.merged_polygons.forEach(points => {
                        polygons.push({
                            id: 'merged',
                            points: points,
                            fill: firstSelected.fill,
                            stroke: firstSelected.stroke
                        });
                    });

                    selectedIds.clear();
                    hiddenIds = newHiddenIds;
                    hasChanges = true;

                    renderSVG(currentSvgData);
                    renderBlockList();
                    updateStatus();
                    updateButtons();

                    showToast(`Merged ${selectedIndices.length} blocks into ${result.merged_polygons.length}`, 'success');
                } else {
                    showToast('Merge failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showToast('Merge failed: ' + error.message, 'error');
            }
        }

        async function cutSelectedFromAll() {
            if (selectedIds.size === 0) {
                showToast('No polygons selected to cut', 'warning');
                return;
            }

            // Group selected polygons (cutters) by block_id
            const cuttersByBlock = {};  // block_id -> [points]
            selectedIds.forEach(idx => {
                const poly = polygons[idx];
                const blockId = poly.block_id;
                if (blockId) {
                    if (!cuttersByBlock[blockId]) {
                        cuttersByBlock[blockId] = [];
                    }
                    cuttersByBlock[blockId].push(poly.points);
                }
            });

            // Group target polygons by block_id (non-selected polygons in same blocks as cutters)
            const targetsByBlock = {};  // block_id -> [{poly, idx}]
            polygons.forEach((poly, idx) => {
                if (!selectedIds.has(idx) && poly.block_id && cuttersByBlock[poly.block_id]) {
                    if (!targetsByBlock[poly.block_id]) {
                        targetsByBlock[poly.block_id] = [];
                    }
                    targetsByBlock[poly.block_id].push({ poly, idx });
                }
            });

            // Collect unchanged polygons (not selected, not in a block with selected cutters)
            const unchangedPolygons = [];
            polygons.forEach((poly, idx) => {
                if (!selectedIds.has(idx) && (!poly.block_id || !cuttersByBlock[poly.block_id])) {
                    unchangedPolygons.push(poly);
                }
            });

            // Check if we have any targets to process
            const blockIds = Object.keys(targetsByBlock);
            if (blockIds.length === 0) {
                // No same-block targets, just remove the selected polygons
                const cutterCount = selectedIds.size;
                polygons = unchangedPolygons;
                selectedIds.clear();
                hiddenIds.clear();
                reapplyIsolationMode();
                hasChanges = true;
                renderSVG(currentSvgData);
                renderBlockList();
                updateStatus();
                updateButtons();
                showToast(`Removed ${cutterCount} polygon(s)`, 'success');
                return;
            }

            try {
                // Process each block separately to ensure cutters only affect their own block
                const newPolygons = [...unchangedPolygons];
                let totalCutters = 0;
                let totalTargets = 0;

                for (const blockId of blockIds) {
                    const cutters = cuttersByBlock[blockId];
                    const targets = targetsByBlock[blockId];
                    if (!cutters || !targets || targets.length === 0) continue;

                    totalCutters += cutters.length;
                    totalTargets += targets.length;

                    const response = await fetch('/api/cut', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            cutter_polygons: cutters,
                            target_polygons: targets.map(t => t.poly.points)
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        result.results.forEach(entry => {
                            const original = targets[entry.original_index].poly;
                            // Each entry.polygons array may have 0, 1, or multiple polygons
                            entry.polygons.forEach(points => {
                                newPolygons.push({
                                    id: original.id || 'cut-result',
                                    points: points,
                                    fill: original.fill || 'rgba(100,100,200,0.3)',
                                    stroke: original.stroke || 'rgb(100,100,200)',
                                    name: original.name,
                                    block_id: original.block_id,
                                    poly_id: original.poly_id,
                                    plate_x: original.plate_x,
                                    plate_y: original.plate_y
                                });
                            });
                        });
                    } else {
                        throw new Error(result.error || 'Unknown error');
                    }
                }

                polygons = newPolygons;
                selectedIds.clear();
                hiddenIds.clear();  // Reset hidden since indices changed
                reapplyIsolationMode();
                hasChanges = true;

                renderSVG(currentSvgData);
                renderBlockList();
                updateStatus();
                updateButtons();

                showToast(`Cut ${totalCutters} polygon(s) from ${totalTargets} same-block polygon(s)`, 'success');
            } catch (error) {
                showToast('Cut failed: ' + error.message, 'error');
            }
        }

        async function saveChanges() {
            if (!currentPlate || !hasChanges) return;

            try {
                let response;
                if (currentSvgType === 'segmentation') {
                    // Save to segmentation endpoint (updates both segmentation.svg and block files)
                    response = await fetch(`/api/segmentation/${currentPlate.volume}/${currentPlate.plate_id}/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ polygons: polygons })
                    });
                } else {
                    // Save to plate endpoint
                    response = await fetch(`/api/plate/${currentPlate.volume}/${currentPlate.plate_id}/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ polygons: polygons })
                    });
                }

                const result = await response.json();

                if (result.success) {
                    hasChanges = false;
                    deletedPolygons = [];
                    deleteHistory = [];
                    updateStatus();
                    updateButtons();
                    updateTabCounts();
                    renderDeletedList();

                    if (currentSvgType === 'segmentation') {
                        const blockFileCount = Object.keys(result.block_files || {}).length;
                        showToast(`Saved ${result.polygon_count} polygons in ${result.block_count} blocks (${blockFileCount} files updated)`, 'success');
                    } else {
                        showToast(`Saved ${result.polygon_count} blocks`, 'success');
                    }
                } else {
                    showToast('Save failed: ' + result.error, 'error');
                }
            } catch (error) {
                showToast('Save failed: ' + error.message, 'error');
            }
        }

        // Zoom controls
        function applyZoom() {
            const svgWidth = parseInt(svgCanvas.getAttribute('width')) || 1000;
            const svgHeight = parseInt(svgCanvas.getAttribute('height')) || 1000;

            svgCanvas.style.transform = `scale(${zoom})`;

            // Set container size to match scaled SVG so scrollable area is correct
            const container = document.getElementById('svg-container');
            container.style.width = `${svgWidth * zoom}px`;
            container.style.height = `${svgHeight * zoom}px`;

            document.getElementById('zoom-level').textContent = `${Math.round(zoom * 100)}%`;
        }

        function zoomIn() {
            zoom = Math.min(zoom * 1.25, 4);
            applyZoom();
        }

        function zoomOut() {
            zoom = Math.max(zoom / 1.25, 0.05);
            applyZoom();
        }

        function fitToView() {
            const containerWidth = canvasWrapper.clientWidth;
            const containerHeight = canvasWrapper.clientHeight;
            const svgWidth = parseInt(svgCanvas.getAttribute('width')) || 1000;
            const svgHeight = parseInt(svgCanvas.getAttribute('height')) || 1000;

            const scaleX = containerWidth / svgWidth;
            const scaleY = containerHeight / svgHeight;
            zoom = Math.min(scaleX, scaleY) * 0.95;
            applyZoom();
        }

        // Pan controls
        let isPanning = false;
        let panStartX, panStartY;
        let scrollStartX, scrollStartY;

        const svgContainer = document.getElementById('svg-container');

        canvasWrapper.addEventListener('mousedown', (e) => {
            if (e.target === canvasWrapper || e.target === svgContainer || e.target === svgCanvas || e.target.tagName === 'image') {
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                scrollStartX = canvasWrapper.scrollLeft;
                scrollStartY = canvasWrapper.scrollTop;
                canvasWrapper.classList.add('dragging');
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                canvasWrapper.scrollLeft = scrollStartX - dx;
                canvasWrapper.scrollTop = scrollStartY - dy;
            }
        });

        window.addEventListener('mouseup', () => {
            isPanning = false;
            canvasWrapper.classList.remove('dragging');
        });

        // Mouse wheel zoom (smooth for trackpads, centered on cursor)
        canvasWrapper.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();

                // Normalize deltaY across browsers/devices
                // Trackpads use smaller deltas, mice use larger ones
                let delta = e.deltaY;

                // If deltaMode is 1 (lines) or 2 (pages), convert to pixels
                if (e.deltaMode === 1) delta *= 16;
                if (e.deltaMode === 2) delta *= 100;

                // Clamp delta to prevent extreme jumps
                delta = Math.max(-100, Math.min(100, delta));

                // Calculate zoom factor based on scroll amount
                // Smaller factor = smoother zoom, especially for trackpads
                const zoomFactor = 1 - delta * 0.003;

                // Calculate new zoom with limits
                const oldZoom = zoom;
                const newZoom = Math.max(0.05, Math.min(4, zoom * zoomFactor));

                if (newZoom === oldZoom) return;

                // Get mouse position relative to the canvas wrapper
                const rect = canvasWrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate the point in SVG coordinates under the cursor (before zoom)
                const svgX = (canvasWrapper.scrollLeft + mouseX) / oldZoom;
                const svgY = (canvasWrapper.scrollTop + mouseY) / oldZoom;

                // Apply new zoom
                zoom = newZoom;
                applyZoom();

                // Calculate new scroll position to keep the same SVG point under cursor
                const newScrollLeft = svgX * newZoom - mouseX;
                const newScrollTop = svgY * newZoom - mouseY;

                canvasWrapper.scrollLeft = newScrollLeft;
                canvasWrapper.scrollTop = newScrollTop;
            }
        });

        function setupEventListeners() {
            plateSelect.addEventListener('change', () => {
                const idx = plateSelect.value;
                if (idx !== '') {
                    if (hasChanges && !confirm('You have unsaved changes. Continue?')) {
                        return;
                    }
                    selectedIds.clear();
                    hiddenIds.clear();
                    isolationMode = null;
                    deletedPolygons = [];
                    deleteHistory = [];
                    switchTab('blocks');
                    loadPlate(parseInt(idx));
                }
            });

            btnSave.addEventListener('click', saveChanges);
            btnUndelete.addEventListener('click', undoDelete);
            btnIsolate.addEventListener('click', isolateSmall);
            btnSelectComplexity.addEventListener('click', isolateByComplexity);

            backgroundModeSelect.addEventListener('change', () => {
                backgroundMode = backgroundModeSelect.value;
                if (currentPlate && currentSvgData) {
                    renderSVG(currentSvgData);
                }
            });

            btnZoomIn.addEventListener('click', zoomIn);
            btnZoomOut.addEventListener('click', zoomOut);
            btnZoomFit.addEventListener('click', fitToView);

            // Tab switching
            document.querySelectorAll('.sidebar-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    switchTab(tab.dataset.tab);
                });
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    deleteSelected();
                } else if (e.key === 'u' || e.key === 'U') {
                    e.preventDefault();
                    undoDelete();
                } else if (e.key === 'm' || e.key === 'M') {
                    e.preventDefault();
                    mergeSelected();
                } else if (e.key === 'z' || e.key === 'Z') {
                    e.preventDefault();
                    cutSelectedFromAll();
                } else if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    hideSelected();
                } else if (e.key === 's' && !(e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    showAll();
                } else if (e.key === 'l' || e.key === 'L') {
                    e.preventDefault();
                    toggleLabels();
                } else if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    isolateSmall();
                } else if (e.key === 'x' || e.key === 'X') {
                    e.preventDefault();
                    deleteVisible();
                } else if (e.key === 'f' || e.key === 'F') {
                    e.preventDefault();
                    toggleFlash();
                } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveChanges();
                } else if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                    e.preventDefault();
                    selectAll();
                } else if (e.key === 'Escape') {
                    deselectAll();
                } else if (e.key === '=' || e.key === '+') {
                    zoomIn();
                } else if (e.key === '-') {
                    zoomOut();
                } else if (e.key === '0') {
                    fitToView();
                }
            });

            // Warn before unload with unsaved changes
            window.addEventListener('beforeunload', (e) => {
                if (hasChanges) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Start
        init();
    </script>
</body>
</html>
